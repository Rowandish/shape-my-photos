<?php	if (!defined("_SHAPE_YOUR_LIFE_DEFAULT_PATH"))		exit();	include_once(_SHAPE_YOUR_LIFE_DEFAULT_PATH."/php/shape/image_shape_covering.class.php");	include_once(_SHAPE_YOUR_LIFE_DEFAULT_PATH."/php/shape/alphabetMatrix.php");	define("HIGHVAL", 999999);	define("SIGN_WIDTH", 295);    define("SIGN_HEIGHT", 11);		class shaper {		function __construct($imageList, $shapeList, $color_policy, $width = 40, $height = 40, $margin = 2, $cols = 11, $rows = 11, $canRepeat=true, $dx='auto', $dy=0, $offsetX=1, $offsetY=0)		{			$this->imageList = $imageList;			shuffle($this->imageList);			$this->_tempImageList = array();			$this->shapeList = $shapeList;			$this->dispositionXAuto = false;			$this->dispositionYAuto = false;			if ($dx === 'auto')				$this->dispositionXAuto = true;			if ($dy === 'auto')				$this->dispositionYAuto = true;			$this->margin = $margin;			$this->width = $width;			$this->height = $height;			$this->cols = $cols;			$this->rows = $rows;			$this->color_policy = $color_policy;			$this->canRepeat = $canRepeat;			$this->dx = $dx;			$this->dy = $dy;			$this->offsetX = $offsetX;			$this->offsetY = $offsetY;		}		public static function calcSize($size, $width, $height, $margin)		{			return array(pow(2, $size)*($width+$margin) - $margin, pow(2, $size)*($height+$margin) - $margin);		}				public function &generateImages() {			if (count($this->_tempImageList) == 0) {				$this->_tempImageList = $this->cloneImages($this->imageList);			}			return $this->_tempImageList;		}		public function generate()		{			$imagesArray = array();			foreach ($this->shapeList as $shape)			{				/*if ($this->canRepeat)					$imgList = $this->cloneImages($this->imageList);				else					$imgList = $this->imageList;*/				if ($shape."" === $shape && !method_exists("GEOMETRY", $shape))					$this->writeLetters($imagesArray, $shape, $imgList);				else					$imagesArray[] = ( $this->generateImageDisposition($shape) );			}			return $this->generateCSSShapeFormat($imagesArray);		}		public function generate2()		{			$imagesArray = array();			foreach ($this->shapeList as $shape)			{				/*if ($this->canRepeat)					$imgList = $this->cloneImages($this->imageList);				else					$imgList = $this->imageList;*/				if ($shape."" === $shape && !method_exists("GEOMETRY", $shape))					$this->writeLetters($imagesArray, $shape, $imgList);				else					$imagesArray[] = ( $this->generateImageDisposition($shape) );			}			return $this->generateJSObject($imagesArray);		}		public function generateImageDisposition($shape)		{			$images = &$this->generateImages();			if (!is_array($shape))				$shape = new geometric_shape($shape, $this->cols, $this->rows);			$myGrid = new grid($shape, $this->width, $this->height);			$this->dispositionImage($myGrid, 3, $images);			return $myGrid;		}		function writeLetters(&$imagesArray, $text) {			$text = strtoupper($text);			for ($i = 0; $i <= strlen($text); $i++) {				if (array_key_exists($text[$i], LETTERS::$ALPHABET))					$letter = LETTERS::$ALPHABET[$text[$i]];				else					$letter = LETTERS::$SPACE;				$imagesArray[] = $this->generateImageDisposition($letter);			}		}		private function cloneImages($images)		{			$imgList = array();			foreach ($images as $img)				$imgList[] = clone $img;			//shuffle($imgList);			return $imgList;		}		private function dispositionImage($myGrid, $maxSize, &$images)		{			$sizes = $maxSize-1;			$toBuild = true;			while ($sizes >= 0)			{				if (count($images) <= 0)				{					if ($this->canRepeat)						$images = &$this->generateImages();					else						break;				}				$s = $sizes;				$pos = $myGrid->get_free($s, $toBuild);				if ($pos == null)				{					$sizes = $s - 1;					continue;				}				$chosenImage = $myGrid->fill_position($pos[0], $pos[1], $s, $images, $this->color_policy);				$key = array_search($chosenImage, $images);				array_splice($images, $key, 1);				$toBuild = false;			}		}				public function generateJSObject($imagesArray) {			$images = array();			$iTraslate = 0;			$jTraslate = 0;			for ($k = 0; $k < count($imagesArray); $k++)			{				$iMax = -1;				$jMax = -1;				$imagesGrid = $imagesArray[$k];				for ($i = 0; $i < $imagesArray[$k]->width(); $i++) {					for ($j = 0; $j < $imagesArray[$k]->height(); $j++) {						if ($imagesArray[$k]->matrix[$i][$j]->isCovered)						{							$iMax = ($i>$iMax) ? $i : $iMax;							$jMax = ($j>$jMax) ? $j : $jMax;						}						if (!$imagesArray[$k]->matrix[$i][$j]->isCovered || !$imagesArray[$k]->matrix[$i][$j]->toShow)							continue;						$image = array();						$image["width"] = $imagesGrid->matrix[$i][$j]->image->width;						$image["height"] = $imagesGrid->matrix[$i][$j]->image->height;						$image["size"] = $imagesGrid->matrix[$i][$j]->image->size + 1;						$image["i"] = $i+$iTraslate;						$image["j"] = $j+$jTraslate;						$image["url"] = $imagesGrid->matrix[$i][$j]->image->url;						$images[] = $image;					}				}				if ($iMax == -1)					$iMax = $imagesArray[$k]->width() / 2;				if ($jMax == -1)					$jMax = $imagesArray[$k]->height() / 2;								$iTraslate += ($this->dispositionXAuto ? $iMax + 1 : $this->dx) + $this->offsetX;				$jTraslate += ($this->dispositionYAuto ? $jMax + 1 : $this->dy) + $this->offsetY;			}			return $images;		}		public function generateCSSShapeFormat($imagesArray) {			$images = array();			$dy = $dx = 0;			$positionx = 0;			$positiony = 0;			for ($k = 0; $k < count($imagesArray); $k++) {				for ($i = 0; $i < $imagesArray[$k]->width(); $i++) {					for ($j = 0; $j < $imagesArray[$k]->height(); $j++) {						if (!$imagesArray[$k]->matrix[$i][$j]->isCovered || !$imagesArray[$k]->matrix[$i][$j]->toShow)							continue;						$image = $this->calculateImageInfos($imagesArray[$k], $i, $j, $positionx, $positiony);						$images [] = $image;					}				}				$dimensions = $this->findShapeMargin($imagesArray[$k]);				if ($this->dispositionXAuto)					$dx = $dimensions[0];				if ($this->dispositionYAuto)					$dy = $dimensions[1];				$positionx += $dx;				$positiony += $dy;			}			return $images;		}		private function findShapeMargin($imageArray)		{			$dx_searched = false;			$dy_searched = false;			for ($i = 0; $i < $imageArray->width(); $i++)			{				for ($j = 0; $j < $imageArray->height(); $j++) {					if ((is_bool($dx_searched) || $i+2 > $dx_searched) && $imageArray->matrix[$i][$j]->isCovered)						$dx_searched = $i + 1 + $this->offsetX;					if ((is_bool($dx_searched) || $j+2 > $dy_searched) && $imageArray->matrix[$i][$j]->isCovered)						$dy_searched = $j + 1 + $this->offsetY;				}			}			$dx = (is_bool($dx_searched) === false ? $dx_searched : $imageArray->width() / 2)*($this->width+$this->margin);			$dy = (is_bool($dy_searched) === false ? $dy_searched : $imageArray->height() / 2)*($this->height+$this->margin);			return array($dx, $dy);		}		private function calculateImageInfos($imagesGrid, $i, $j, $deltax, $deltay)		{			$image = array();			$image["url"] = $imagesGrid->matrix[$i][$j]->image->url;			$image["size"] = $imagesGrid->matrix[$i][$j]->image->size + 1;			$image["top"] = ($j*($this->height+$this->margin) + $deltay)."px";			$image["left"] = ($i*($this->width+$this->margin) + $deltax)."px";			$image["width"] = $image["height"] = "auto";			list($zw, $zh) = shaper::calcSize($imagesGrid->matrix[$i][$j]->image->size, $this->width, $this->height, $this->margin);			$image["container-width"] = $zw."px";			$image["container-height"] = $zh."px";			$image["margin-left"] = $image["margin-top"] = "0px";						$deltaW = $imagesGrid->matrix[$i][$j]->image->width / float($zw);			$deltaH = $imagesGrid->matrix[$i][$j]->image->height / float($zh);						if ($deltaW > $deltaH)			{				$image["height"] = $zh . "px";				$margin_left = $imagesGrid->matrix[$i][$j]->image->width * $zh / float($imagesGrid->matrix[$i][$j]->image->height);				$image["margin-left"] = int(($margin_left - $zw)/-2) . "px";			}			else			{				$image["width"] = $zw . "px";				$margin_top = $imagesGrid->matrix[$i][$j]->image->height * $zw / float($imagesGrid->matrix[$i][$j]->image->width);				$image["margin-top"] = int(($margin_top - $zh)/-2) . "px";			}			return $image;		}                        private static function recoverCompositionInfos($imagesArray) {            $minWidth = $minHeight = $margin = HIGHVAL;            foreach ($imagesArray as $img) {                if (intval($img["container-width"]) < $minWidth)                    $minWidth = intval($img["container-width"]);                if (intval($img["container-height"]) < $minHeight)                    $minHeight = intval($img["container-height"]);            }            foreach ($imagesArray as $img)                foreach ($imagesArray as $img2)                    if ($img["top"] != $img2["top"] && abs(intval($img["top"]) - intval($img2["top"])) % $minHeight < $margin)                            $margin = abs(intval($img["top"]) - intval($img2["top"])) % $minHeight;            $maxX = $maxY = 0;            $minX = $minY = HIGHVAL;            foreach ($imagesArray as $img) {                    if (intval($img["top"]) + pow(2, $img["size"]-1)*($minHeight+$margin) > $maxY)                            $maxY = intval($img["top"]) + pow(2, $img["size"]-1)*($minHeight+$margin);                    if (intval($img["left"]) + pow(2, $img["size"]-1)*($minWidth+$margin) > $maxX)                            $maxX = intval($img["left"]) + pow(2, $img["size"]-1)*($minWidth+$margin);                    if (intval($img["top"]) < $minY)                            $minY = intval($img["top"]);                    if (intval($img["left"]) < $minX)                            $minX = intval($img["left"]);            }            $minX = $minX == HIGHVAL ? 0 : $minX;            $minY = $minY == HIGHVAL ? 0 : $minY;            return array($maxX, $maxY, $minX, $minY, $minWidth, $minHeight, $margin);        }        public static function imageSave($imagesArray, $background, $zoom=1.5, $filter=imagick::FILTER_QUADRATIC, $compression="png") {                list($maxX, $maxY, $minX, $minY, $minWidth, $minHeight, $margin) = shaper::recoverCompositionInfos($imagesArray);                $imgWidth = $maxX+$margin-$minX;                $imgHeight = $maxY+$margin-$minY;                $color = sprintf("#%06x", intval($background[0]<<16) | (intval($background[1]) << 8) | (intval($background[2])));                $temp = new Imagick();                $temp->newImage($imgWidth*$zoom, $imgHeight*$zoom, $color);                if ($compression == "png") {	                $temp->setImageFormat("png");	                $temp->setImageCompression(Imagick::COMPRESSION_UNDEFINED);	                $temp->setImageCompressionQuality(0);                } else if ($compression == "jpeg") {					$temp->setImageFormat('jpeg'); 					$temp->setCompression(Imagick::COMPRESSION_JPEG);					$temp->setCompressionQuality(90);                }                $contaimmagini = 0;                foreach ($imagesArray as $img) {                        $imgsrc = new Imagick();                        $tempfilename = "/tmp/".md5($img["url"]).end(explode("/", $img["url"]));                        if (file_exists($tempfilename)) {							$f = fopen($tempfilename, "rb");							$contaimmagini++;						} else							$f = fopen($img["url"], "rb");                        $imgsrc->readImageFile($f);                        $width = $imgsrc->getImageWidth();                        $height = $imgsrc->getImageHeight();                        list($destW, $destH) = shaper::calcSize($img["size"]-1, $minWidth, $minHeight, $margin);                        $destW *= $zoom;                        $destH *= $zoom;                        $marginx = $marginy = 0;                        if ($img["width"] == "auto") {                                $_width = $height * $destW / $destH;                                $marginx = ($width - $_width)/2;                                $width = $_width;                        } else {                                $_height = $width * $destH / $destW;                                $marginy = ($height - $_height)/2;                                $height = $_height;                        }                        $imgsrc->cropImage($width, $height, $marginx, $marginy);                        $imgsrc->resizeImage($destW, $destH, $filter, 1);                        $temp->compositeImage($imgsrc, imagick::COMPOSITE_COPY, (intval($img["left"]) + $margin - $minX)*$zoom , (intval($img["top"]) + $margin - $minY)*$zoom);                        $imgsrc->destroy();                }                return $temp;        }        public static function imageSave2($imagesArray, $background, $signature = true, $zoom=1.5, $filter=OpenCV\Image::INTER_AREA) {                list($maxX, $maxY, $minX, $minY, $minWidth, $minHeight, $margin) = shaper::recoverCompositionInfos($imagesArray);                $imgWidth = $maxX+$margin-$minX;                $imgHeight = $maxY+$margin-$minY;                if ($signature)	                $temp = new OpenCV\Image(max($imgWidth*$zoom, SIGN_WIDTH), $imgHeight*$zoom+SIGN_HEIGHT, OpenCV\Image::DEPTH_8U, 3);	            else	            	$temp = new OpenCV\Image($imgWidth*$zoom, $imgHeight*$zoom, OpenCV\Image::DEPTH_8U, 3);                $temp->fillColor($background[0], $background[1], $background[2]);                $contaimmagini = 0;                foreach ($imagesArray as $img) {                        $tempfilename = "/tmp/".md5($img["url"]).end(explode("/", $img["url"]));                        if (file_exists($tempfilename)) {							$f = $tempfilename;							$contaimmagini++;						} else {							$f = "/tmp/".md5($img["url"]).end(explode("/", $img["url"]));							file_put_contents($f, file_get_contents($img["url"]));						}                        $imgsrc = OpenCV\Image::load($f, OpenCV\Image::LOAD_IMAGE_COLOR);                        $infos = $imgsrc->getImageROI();                        $width = $infos["width"];                        $height = $infos["height"];                        list($destW, $destH) = shaper::calcSize($img["size"]-1, $minWidth, $minHeight, $margin);                        $destW *= $zoom;                        $destH *= $zoom;                        $marginx = $marginy = 0;                        if ($img["width"] == "auto") {                                $_width = $height * $destW / $destH;                                $marginx = ($width - $_width)/2;                                $width = $_width;                        } else {                                $_height = $width * $destH / $destW;                                $marginy = ($height - $_height)/2;                                $height = $_height;                        }                        $imgsrc->setImageROI($marginx, $marginy, $width, $height);                		$dest = new OpenCV\Image($destW, $destH, OpenCV\Image::DEPTH_8U, 3);                        $imgsrc->resize($dest, $filter);                        $temp->setImageROI((intval($img["left"]) + $margin - $minX)*$zoom, (intval($img["top"]) + $margin - $minY)*$zoom, $destW, $destH);                        $temp->copy($dest);                        $temp->resetImageROI();                        unset($dest);                        unset($imgsrc);                }                if ($signature)                {					$imgsrc = OpenCV\Image::load("/app/www/images/signature.png", OpenCV\Image::LOAD_IMAGE_COLOR);	                $temp->setImageROI(max($imgWidth*$zoom, SIGN_WIDTH) - SIGN_WIDTH, $imgHeight*$zoom, SIGN_WIDTH, SIGN_HEIGHT);	                $temp->copy($imgsrc);					$temp->resetImageROI();	                unset($imgsrc);                }                return $temp;        }	};        	function generateImageDistanceMatrix($images, $generate = true){		$stats = array();		$_temp = imagecreatetruecolor(1,1);		for ($i = 0; $i < count($images); $i++)		{			if ($generate) {				$temp1 = imagecreatefromstring(file_get_contents($images[$i]));				$width = imagesx($temp1);				$height = imagesy($temp1);				fastimagecopyresampled($_temp, $temp1, 0, 0, 0, 0, 1, 1, $width, $height);				$pixel = imagecolorat($_temp, 0, 0);				imagedestroy($temp1);			} else {				list($width, $height) = getimagesize($images[$i]);				$pixel = 0;			}			$avg1 = array( ($pixel >> 16) & 0xFF, ($pixel >> 8) & 0xFF, $pixel & 0xFF);			$stats[] = new image($avg1, $images[$i], $width, $height);		}		imagedestroy($_temp);		return $stats;	};	function generateCSSShapeFormat($imagesArray, $minWidth, $minHeight, $margin) {		$dataClient = array();		foreach ($imagesArray as $value)		{			$width = $value["width"];			$height = $value["height"];			$size = $value["size"] - 1;			$i = $value["i"];			$j = $value["j"];			$url = $value["url"];			$shapeData = array("url"=>$url,"size"=>$size+1,"top"=>null,"left"=>null,"width"=>"auto","height"=>"auto",					"container-width"=>null,"container-height"=>null,"margin-left"=>"0px","margin-top"=>"0px");			$realWidth = (pow(2,$size)*($minWidth+$margin))-$margin;			$realHeight = (pow(2,$size)*($minHeight+$margin))-$margin;			$shapeData["container-width"] = $realWidth."px";			$shapeData["container-height"] =$realHeight."px";			$deltaWidth = $width/(pow(2,$size)*$minWidth);			$deltaHeight = $height/(pow(2,$size)*$minHeight);			if ($deltaWidth>$deltaHeight)			{				$shapeData["height"] = $shapeData["container-height"];				$shapeData["margin-left"] = intval((($width*$realHeight/$height-$realWidth)/-2))."px";			}			else			{				$shapeData["width"] = $shapeData["container-width"];				$shapeData["margin-top"] = intval((($height*$realWidth/$width-$realHeight)/-2))."px";			}			$shapeData["top"] = ($j*($minHeight+$margin))."px";			$shapeData["left"] = ($i*($minWidth+$margin))."px";			$dataClient[] = $shapeData;		}		return $dataClient;	}