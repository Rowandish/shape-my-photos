<?phpfunction int($val) {	return intval($val);}function str($val) {	return $val."";}function float($val) {	return $val+0.0;}class GEOMETRY {    public static function __ELLIPSE($x, $y, $d1, $d2) {            return round_int(pow((($x-($d1/2.0))/($d1/2.0)),2) + pow(($y-($d2/2.0))/($d2/2.0), 2)) < 1.0;    }    public static function __RECTANGLE($x, $y, $d1, $d2) {            return $x >= 0 && $y >= 0 && $x < $d1 && $y < $d2;    }    public static function __TRIANGLE_EQ_REVERSE($x, $y, $d1, $d2) {            return $y >= 0 && $y < $d2 && $x >= $y && $x < $d1 - $y;    }    public static function __TRIANGLE_EQ($x, $y, $d1, $d2) {            return $y >= 0 && $y < $d2 && $x < round(($y + $d1)/2.0) && $x >= round(($d1 - $y)/2.0);    }    public static function __HOURGLASS($x, $y, $d1, $d2) {            return ($y >= 0 && $y < $d2 && $x >= $d1 - $y - 1 && $x <= $y) || ($y >= 0 && $y < $d2 && $x >= $y && $x < $d1 - $y);    }    public static function __TRIANGLE_RECT($x, $y, $d1, $d2) {            return $y >= 0 && $y < $d2 && $x >= 0 && $x < $d1 - $y*($d2/$d1);    }    public static function __TRIANGLE_RECT_REVERSE($x, $y, $d1, $d2) {            return $y >= 0 && $y < $d2 && $x < $d1 && $x >= $d1 - $y*($d2/$d1);    }    public static function __CROSS($x, $y, $d1, $d2) {            return GEOMETRY::__RECTANGLE($x, $y-($d1 - 4)/2, $d1, 4) || GEOMETRY::__RECTANGLE($x-($d2 - 4)/2, $y, 4, $d2);    }    public static function __HALF_HEART_RIGHT($x, $y, $d1, $d2) {            return GEOMETRY::__TRIANGLE_RECT($x*2,$y*1.6 - 5,$d1,$d2) || GEOMETRY::__ELLIPSE($x*2 + 1, $y*2 + 1, $d1, $d1);    }    public static function __HALF_HEART_LEFT($x, $y, $d1, $d2) {    		//return GEOMETRY::__HALF_HEART_RIGHT($d1 - $x - 1, $y, $d1, $d2);            return GEOMETRY::__TRIANGLE_RECT(-$x*2 + 9,$y*1.6 - 5,$d1,$d2) || GEOMETRY::__ELLIPSE(-$x*2 + 9, $y*2 + 1, $d1, $d1);    }    public static function __COVER_PHOTO($x, $y, $d1, $d2) {            return $x >= 0 && $y >= 0 && $x < $d1 && $y < $d2/2;    }    public static function __HEART($x, $y, $d1, $d2) {    		return GEOMETRY::$__HEART[$x][$y] === 1;    }    public static function __STAR($x, $y, $d1, $d2) {    		return GEOMETRY::$__STAR[$x][$y] === 1;    }    public static function __BUTTERFLY($x, $y, $d1, $d2) {    		return GEOMETRY::$__BUTTERFLY[$x][$y] === 1;    }    public static function __SMILE($x, $y, $d1, $d2) {    		return GEOMETRY::$__SMILE[$x][$y] === 1;    }    private static $__HEART = array(array(0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0),array(0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0),array(1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0),array(1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0),array(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0),array(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1),array(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0),array(1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0),array(1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0),array(0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0),array(0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0));    private static $__STAR = array(array(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0), array(0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0), array(0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0), array(0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0), array(0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0), array(1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0), array(0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0), array(0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0), array(0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0), array(0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0), array(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0));    private static $__BUTTERFLY = array(array(1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0), array(1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1), array(0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1), array(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0), array(0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0), array(0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0), array(0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0), array(0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0), array(0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1), array(1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1), array(1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0));    private static $__SMILE = array(array(0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0), array(0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0), array(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0), array(1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1), array(1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1), array(1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1), array(1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1), array(1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1), array(0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0), array(0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0), array(0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0));}define(SIMILAR_IMAGES, 0);define(DIFFERENT_IMAGES, 1);function round_int($x) {	if ($x-int($x)<0.8)		return int($x);	else		return int($x+1);}function colorDistance($color1, $color2) {	return pow(pow($color1[0] - $color2[0], 2) + pow($color1[1] - $color2[1], 2) + pow($color1[2] - $color2[2], 2), 0.5);}class grid {	function __construct($shape, $baseElementWidth, $baseElementHeight) {		$this->baseElementWidth = $baseElementWidth;		$this->baseElementHeight = $baseElementHeight;		if (is_array($shape)) {			$this->matrix = array();			for ($x = 0; $x < count($shape); $x++) {				$this->matrix[] = array();				for ($y = 0; $y < count($shape); $y++) {					if ($shape[$x][$y])						$this->matrix[$x][$y] = new grid_element($x, $y, true);					else						$this->matrix[$x][$y] = new grid_element($x, $y, false);				}			}		} else {			$maxWidthHeight = max($shape->width, $shape->height);			$this->matrix = array();			for ($x = 0; $x < $maxWidthHeight; $x++) {				$this->matrix[] = array();				for ($y = 0; $y < $maxWidthHeight; $y++) {					if ($shape->is_inside($x, $y))						$this->matrix[$x][$y] = new grid_element($x, $y, true);					else						$this->matrix[$x][$y] = new grid_element($x, $y, false);				}			}		}	}	public function __toString() {		$result = "";		for ($y = 0; $y < count($this->matrix); $y++) {			for ($x = 0; $x < count($this->matrix); $x++)				$result .= str($this->matrix[$x][$y]) . ",";			$result .="\n";		}		return $result;	}	function length() {		return count($this->matrix);	}	function width() {		return count($this->matrix);	}	function height() {		if (count($this->matrix) == 0)			return 0;		else			return count($this->matrix[0]);	}	function check_neighbors($i, $j, $size) {		for ($k = 0; $k < pow(2, $size); $k++) {			if ($i+$k >= count($this->matrix))				return false;			for ($w = 0; $w < pow(2, $size); $w++) {				if ($j+$w >= count($this->matrix))					return false;				if (!$this->matrix[$i+$k][$j+$w]->active || $this->matrix[$i+$k][$j+$w]->isCovered)					return false;			}		}		return true;	}	function is_connected($i, $j, $size) {		$k = -1;		for ($w = 0; $w < pow(2, $size); $w++)			if ($i+$k >= 0)				if ($this->matrix[$i+$k][$j+$w]->isCovered)					return true;		$k = pow(2, $size);		for ($w = 0; $w < pow(2, $size); $w++)			if ($i+$k < count($this->matrix))				if ($this->matrix[$i+$k][$j+$w]->isCovered)					return true;		$w = -1;		for ($k = 0; $k < pow(2, $size); $k++)			if ($j+$w >= 0)				if ($this->matrix[$i+$k][$j+$w]->isCovered)					return true;		$w = pow(2, $size);		for ($k = 0; $k < pow(2, $size); $k++)			if ($j+$w < count($this->matrix))				if ($this->matrix[$i+$k][$j+$w]->isCovered)					return true;		return false;	}	function get_free($size, $toBuild) {		$mat_temp = array();		for ($i = 0; $i < count($this->matrix); $i++)			for ($j = 0; $j < count($this->matrix); $j++)				$mat_temp[] = array($i, $j);		$counter = 0;		while (count($mat_temp) > 0) {			$index = rand(0, count($mat_temp)-1);			$val = $mat_temp[$index];			if ($this->check_neighbors($val[0], $val[1], $size)) {				if ($toBuild || $this->is_connected($val[0], $val[1], $size))					return $val;			} else				array_splice($mat_temp, $index, 1);			$counter++;			if ($counter > 100)				$toBuild = true;		}		return null;	}	function find_connected_color($i, $j, $size) {		$colors = array();		$k = -1;		for ($w = 0; $w < pow(2, $size); $w++)			if ($i+$k >= 0)				if ($this->matrix[$i+$k][$j+$w]->isCovered)					$colors[] = $this->matrix[$i+$k][$j+$w]->image->color;		$k = pow(2, $size);		for ($w = 0; $w < pow(2, $size); $w++)			if ($i+$k < count($this->matrix))				if ($this->matrix[$i+$k][$j+$w]->isCovered)					$colors[] = $this->matrix[$i+$k][$j+$w]->image->color;		$w = -1;		for ($k = 0; $k < pow(2, $size); $k++)			if ($j+$w >= 0)				if ($this->matrix[$i+$k][$j+$w]->isCovered)					$colors[] = ($this->matrix[$i+$k][$j+$w]->image->color);		$w = pow(2, $size);		for ($k = 0; $k < pow(2, $size); $k++)			if ($j+$w < count($this->matrix))				if ($this->matrix[$i+$k][$j+$w]->isCovered)					$colors[] = ($this->matrix[$i+$k][$j+$w]->image->color);							if (count($colors) == 0)			return null;				$avgR = 0.0;		$avgG = 0.0;		$avgB = 0.0;				foreach ($colors as $col) {			$avgR += $col[0];			$avgG += $col[1];			$avgB += $col[2];		}		$avgR /= float(count($colors));		$avgG /= float(count($colors));		$avgB /= float(count($colors));				return array($avgR, $avgG, $avgB);	}	function find_better_image_to_fit($i, $j, $size, $images, $type) {		$refColor = $this->find_connected_color($i, $j, $size);		if ($refColor == null) {			//la prima imagine la sparo a botto perché è quella che darà riferimento alle altre come colore.			$img = null;			$cont = 0;			do {				$img = $images[rand(0, count($images)-1)];			} while(++$cont < 50 && ($img->width < $this->baseElementWidth*(pow(2, $size)) || $img->height < $this->baseElementHeight*(pow(2, $size))));			return $img;		}		$avg = 10000000;//colorDistance($images[0].color, $refColor);		$chosenImg = $images[0];		foreach($images as $img) {			$tempAvg = colorDistance($img->color, $refColor);			if ((($tempAvg < $avg && $type == 0) || ($tempAvg > $avg && $type == 1)) && $img->width >= $this->baseElementWidth*(pow(2, $size)) && $img->height >= $this->baseElementHeight*(pow(2, $size))) {				$avg = $tempAvg;				$chosenImg = $img;			}		}		return $chosenImg;	}	function fill_position($i, $j, $size, $images, $type) {		#finding better image to fit		$image = $this->find_better_image_to_fit($i, $j, $size, $images, $type);		#adding the chosen image		for ($k = 0; $k < pow(2, $size); $k++) {			for ($w = 0; $w < pow(2, $size); $w++) {				$this->matrix[$i+$k][$j+$w]->isCovered = true;				$this->matrix[$i+$k][$j+$w]->image = $image;			}		}		$this->matrix[$i][$j]->toShow = true;		$image->size = $size;		return $image;	}}class image {	function __construct($color, $url, $width, $height) {		$this->size = 0;		$this->width = $width;		$this->height = $height;		$this->color = $color;		$this->url = $url;	}}	class geometric_shape {		function __construct($equation, $width, $height) {		$this->equation = $equation;		$this->width = $width;		$this->height = $height;	}	function is_inside($x, $y) {                $function_name = $this->equation;                return GEOMETRY::$function_name($x, $y, $this->width, $this->height);	}}		class grid_element {	function __construct($i, $j, $active) {		$this->i = $i;		$this->j = $j;		$this->active = $active;		$this->isCovered = false;		$this->toShow = false;		$this->image = null;	}    public function __toString() {		if (!$this->active) {			return str(0);		}		else if ($this->isCovered) {			return str(2+$this->image->size);		}		else {			return str(1);		}	}}			?>